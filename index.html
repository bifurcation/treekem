<!doctype html5>
<html>

<head>
<title>TKEM</title>
<script src="./dist/index.js"></script>
<script src="./web/jquery-3.3.1.min.js"></script>
<script>

const ok = (x => { window.pout = x; console.log("ok", x); });
const err = (x => { window.pout = x; console.log("err", x); });

function hex(ab) {
  const arr = Array.from(new Uint8Array(ab));
  return arr.map(x => ('0' + x.toString(16)).slice(-2)).join('');
}

let members = [];
let renderers = [];

function addMember(m) {
  members.push(m);

  // Add a tree
  let index = m.index;
  let divID = "tree" + index;
  let tag = $(`<div class="number">${index}</div>`);
  let div = $(`<div id="${divID}" class="tree"></div>`);
  div.append(tag);
  $("#members").append(div);

  // Render
  let r = new Renderer(divID);
  r.render(m.size, m.nodes);
  renderers.push(r);

  // Add an update button
  let buttonID = "update" + index;
  let button = $(`<button id="buttonID">Update(${index})</button>`);
  button.click(() => { update(index); });
  $("#buttons").append(button);
}

async function update(k) {
  let leaf = crypto.getRandomValues(new Uint8Array(32));
  let update = await members[k].update(leaf);
  
  for (m2 of members) {
    if (m2.tkem.index == k) {
      await m2.handleSelfUpdate(update, leaf);
    } else {
      await m2.handleUpdate(update);
    }
    renderers[m2.index].render(m2.size, m2.nodes);
  }
}

async function userAdd() {
  let last = members[members.length - 1];
  let gik = last.groupInitKey;
  
  let leaf = crypto.getRandomValues(new Uint8Array(32));
  let ua = await TKEMState.join(leaf, gik);

  for (let m of members) {
    await m.handleUserAdd(ua);
    renderers[m.index].render(m.size, m.nodes);
  }

  let joiner = await TKEMState.fromUserAdd(leaf, ua, gik);
  addMember(joiner);
}

async function groupAdd() {
  let last = members[members.length - 1];
  
  let initKP = await iota(crypto.getRandomValues(new Uint8Array(4)));
  let ga = await last.add(initKP.publicKey);
 
  for (let m of members) {
    await m.handleGroupAdd(ga);
    renderers[m.index].render(m.size, m.nodes);
  }

  let joiner = await TKEMState.fromGroupAdd(initKP.privateKey, ga);
  addMember(joiner);
}

$(document).ready(async () => {
  $("#userAdd").click(userAdd);
  $("#groupAdd").click(groupAdd);

  let leaf = crypto.getRandomValues(new Uint8Array(32));
  let creator = await TKEMState.oneMemberGroup(leaf);
  addMember(creator);
});

</script>
<style>
body {
  font-family: Menlo, monospace;
  font-size: 10pt;
  margin: 0;
}

#buttons, #legend, #members {
  padding: 2ex;
  width: 100%;
}

#legend {
  background: #ccc;
  border-top: 1px solid #999;
  border-bottom: 1px solid #999;
}

button {
  border: 1px solid #999;
  background: #ccc;
  font-family: Menlo, monospace;
  font-size: 10pt;
  padding: 1ex;
  box-shadow: 1px 1px;
}

div.number {
  margin: 0;
  color: #000;
  background: #ccc;
  text-align: center;
}

div.tree {
  float: left;
  margin: 1ex;
  padding: 0;
  border: 1px solid black;
}

div.tree svg {
  margin: 1ex;
}
</style>
</head>

<body>
  <div id="buttons">
    <button id="userAdd">UserAdd</button>
    <button id="groupAdd">GroupAdd</button>
  </div>
  <div id="legend">
    Filled boxes are nodes with private keys.
    Empty boxes are nodes with only public keys.
    Colors represent hash chains.
    Lightness represents distance along the chain.
  </div>
  <div id="members"></div>
</body>

</html>
